<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labirinto  </title>
  <style>
    .joystick {
  position: fixed;
  bottom: 20px;
  left: 20px;
  width: 120px;
  height: 120px;
  background: rgba(255,255,255,0.05);
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  touch-action: none;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: center;
}

.stick {
  width: 60px;
  height: 60px;
  background: rgba(255,255,255,0.25);
  border: 2px solid rgba(255,255,255,0.5);
  border-radius: 50%;
  transition: transform 0.1s linear;
}

    :root{
      --bg:#0b0b0c;         /* fundo geral */
      --panel:#0f0f12;      /* painéis */
      --wall:#222325;       /* paredes */
      --floor:#0c0c0f;      /* chão */
      --exit:rgb(255, 0, 0);          /* saída */
      --player:rgb(70, 51, 238);        /* jogador */
      --text:#e7e7ea;       /* texto */
      --accent:#9d1d1d;     /* detalhes/hover */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial}
    .wrap{display:flex;flex-direction:column;min-height:100%}
    header{padding:12px 16px;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#0c0c10,#070709);border-bottom:1px solid #16161a}
    .brand{font-weight:700;letter-spacing:.5px}
    .level{opacity:.9}
    main{flex:1;display:grid;place-items:center;position:relative;overflow:hidden}

    /* Canvas container keeps aspect and centers */
    .stage{position:relative;display:inline-block;border-radius:20px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.6), inset 0 0 100px rgba(0,0,0,.6);background:radial-gradient(1200px 800px at 50% 50%, #111 0%, #0a0a0c 40%, #050507 100%)}
    canvas{display:block}

    /* Overlay screens */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.65);backdrop-filter:blur(2px)}
    .panel{background:var(--panel);border:1px solid #1a1a20;border-radius:18px;padding:28px 22px;max-width:min(92vw,560px);box-shadow:0 14px 40px rgba(0,0,0,.55)}
    h1{margin:0 0 8px;font-size:clamp(26px,4vw,40px)}
    p{margin:0 0 14px;opacity:.9;line-height:1.4}
    .btn{cursor:pointer;appearance:none;border:0;border-radius:14px;padding:14px 18px;font-weight:700;background:linear-gradient(180deg,#a32222,#7a1414);color:#a0a0a0;box-shadow:0 10px 20px rgba(0,0,0,.5), inset 0 -2px 0 rgba(255,255,255,.06)}
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}

    /* D-Pad mobile */
    .dpad{position:fixed;left:12px;bottom:12px;display:grid;grid-template-columns:60px 60px 60px;grid-template-rows:60px 60px 60px;gap:8px;opacity:.9;z-index:5}
    .key{display:grid;place-items:center;background:#121217;border:1px solid #202028;border-radius:14px;color:#d6d6da;user-select:none}
    .key:active{background:#171722}
    .k-empty{opacity:0;pointer-events:none}

    /* HUD toast */
    .toast{position:fixed;right:12px;bottom:12px;background:#111116;border:1px solid #20202a;border-radius:12px;padding:10px 12px;font-size:14px;opacity:.9}

    /* Responsividade do canvas */
    @media (max-width: 640px){
      .dpad{grid-template-columns:52px 52px 52px;grid-template-rows:52px 52px 52px}
      .key{border-radius:12px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">Labirinto Sombrio</div>
      <div class="level" id="levelInfo">Fase 1/15</div>
    </header>
    <main>
      <div class="stage" id="stage">
        <canvas id="game" width="800" height="600" aria-label="Labirinto Sombrio"></canvas>
        <div class="overlay" id="startOverlay">
          <div class="panel">
            <h1>Labirinto Sombrio</h1>
            <p>Use as setas ou WASD para se mover. Encontre a saída verde em cada fase. Existem 15 fases: 5 fáceis, 5 intermediárias e 5 difíceis.</p>
            <button class="btn" id="btnStart">Começar</button>
          </div>
        </div>
        <div class="overlay" id="winOverlay" style="display:none">
          <div class="panel">
            <h1>Você venceu!</h1>
            <p>Concluiu todas as 15 fases do Labirinto Sombrio.</p>
            <button class="btn" id="btnRestart">Jogar novamente</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Joystick Mobile -->
<div id="joystick" class="joystick">
  <div id="stick" class="stick"></div>
</div>

<div class="toast" id="toast" style="display:none"></div>

  <script>
    // --- Representação das fases ---
    // 0 = caminho, 1 = parede, 2 = saída, 3 = início do jogador
    const LEVELS = [
      // ====== FÁCEIS (1-5) ======
      // 1 (5x5)
 // 1 (5x7) – simples com curva
 // 1 (5x5) – mais difícil, menos largo
  [
    [1,1,1,1,1],
    [1,3,0,1,1],
    [1,0,1,0,1],
    [1,0,0,2,1],
    [1,1,1,1,1],
  ],

  // 2 (7x7) – mais estreito, com desvios e bloqueios
  [
    [1,1,1,1,1,1,1],
    [1,3,0,1,0,2,1],
    [1,0,1,1,1,0,1],
    [1,0,0,0,1,0,1],
    [1,0,1,0,0,0,1],
    [1,0,0,0,0,0,1],
    [1,1,1,1,1,1,1],
  ],

  // 3 (6x8) – horizontal com armadilhas, largura reduzida
  [
    [1,1,1,1,1,1,1,1],
    [1,3,0,1,0,0,2,1],
    [1,0,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,0,1],
    [1,1,1,1,1,1,1,1],
  ],

  // 4 (7x9) – lateral com múltiplos caminhos, menos largo
  [
    [1,1,1,1,1,1,1,1,1],
    [1,3,0,1,0,0,1,0,1],
    [1,0,1,1,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,2,1],
    [1,1,1,1,1,1,1,1,1],
  ],

  // 5 (8x10) – loops e caminhos mais apertados
  [
    [1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,2,0,0,1],
    [1,0,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,1],
    [1,1,1,0,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1],
  ],

  // 6 (9x12) – bem larga originalmente; agora reduzida e mais bloqueada
  [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,1,0,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,0,1,1,1],
    [1,0,1,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1,1,0,1,1],
    [1,2,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 7 (10x13) – amplo com armadilhas, agora menos largo e mais falso-sucos
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,2,1],
    [1,0,1,1,0,1,0,1,1,0,1,1,1],
    [1,0,0,0,0,0,1,0,1,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,0,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,1,0],
    [1,1,1,1,1,0,1,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 8 (11x13) – muito largo originalmente; reduzido mantendo loops
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,0,1,0,0,0,1,2,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 9 (11x15) – intermediária/difícil, horizontal extenso reduzido
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,0,0,2,1],
    [1,0,1,1,0,1,0,1,1,0,1,1,1,1,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 10 (12x16) – intermediária/difícil, largura reduzida
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,0,0,2,0,1],
    [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 11 (12x18) – labirinto com final escondido, reduzido
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,0,1,0,0,2,0,1],
    [1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,0,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
    [1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 12 (13x20) – muito largo com múltiplos loops -> reduzido e mais complicado
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,0,1,0,0,2,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 13 (14x20) – difíceis, final escondido; reduzido mas com muitos becos
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,1,0,1,0,1,1,0,1,0,1,0,1,1,0,1,2,1],
    [1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 14 (15x20) – muito difícil, largo para os lados -> reduzido e mais trampas
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,0,0,1,0,0,1,0,0,0,1,0,0,2,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],

  // 15 (15x20) – final: muito difícil, labirinto muito largo -> reduzido e com muitos becos
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,0,1,0,1,0,1,1,0,1,0,1,0,1,1,0,1,2,1],
    [1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,1],
    [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ],
];

function resizeCanvas(level) {
  const rows = level.length;
  const cols = level[0].length;

  // calcula tamanho da célula com base na tela
  const cellSize = Math.floor(
    Math.min(window.innerWidth / cols, window.innerHeight / rows)
  );

  canvas.width = cols * cellSize;
  canvas.height = rows * cellSize;

  return cellSize;
}


    // --- Estado do jogo ---
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('startOverlay');
    const winOverlay = document.getElementById('winOverlay');
    const btnStart = document.getElementById('btnStart');
    const btnRestart = document.getElementById('btnRestart');
    const levelInfo = document.getElementById('levelInfo');
    const dpad = document.getElementById('dpad');
    const toast = document.getElementById('toast');

    let currentLevel = 0;
    let player = {x:1, y:1};
    let tile = 40; // tamanho do bloco; será recalculado
    let lightingRadius = 2.2; // em tiles

    function showToast(text){
      toast.textContent = text; toast.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toast.style.display='none', 1400);
    }

    function findStart(level){
      for(let y=0;y<level.length;y++){
        for(let x=0;x<level[0].length;x++){
          if(level[y][x]===3) return {x,y};
        }
      }
      // padrão caso 3 não exista (evitar travas)
      return {x:1,y:1};
    }

    function resizeCanvas(){
      const level = LEVELS[currentLevel];
      const cols = level[0].length;
      const rows = level.length;
      const margin = 24; // respiro dentro do stage
      const maxW = Math.min(window.innerWidth-24*2, 1100);
      const maxH = Math.min(window.innerHeight-120, 780);
      const cellW = Math.floor((maxW - margin) / cols);
      const cellH = Math.floor((maxH - margin) / rows);
      tile = Math.max(16, Math.min(cellW, cellH));
      canvas.width = cols * tile;
      canvas.height = rows * tile;
      stage.style.width = canvas.width + 'px';
      stage.style.height = canvas.height + 'px';
      draw();
    }

    function draw(){
      const level = LEVELS[currentLevel];
      const cols = level[0].length;
      const rows = level.length;


      function resizeCanvas(level) {
  const rows = level.length;
  const cols = level[0].length;

  // calcula tamanho da célula com base na tela
  const cellSize = Math.floor(
    Math.min(window.innerWidth / cols, window.innerHeight / rows)
  );

  canvas.width = cols * cellSize;
  canvas.height = rows * cellSize;

  return cellSize;
}

      // Fundo
      ctx.fillStyle = '#09090c';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Paredes e chão
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const t = level[y][x];
          const px = x*tile, py = y*tile;
          if(t===1){
            ctx.fillStyle = getWallShade(x,y);
            ctx.fillRect(px,py,tile,tile);
          }else{
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(px,py,tile,tile);
          }
          if(t===2){ // saída
            ctx.fillStyle = '#0f6';
            ctx.fillRect(px+tile*0.2, py+tile*0.2, tile*0.6, tile*0.6);
            // brilho da saída
            const g = ctx.createRadialGradient(px+tile/2, py+tile/2, 2, px+tile/2, py+tile/2, tile*0.9);
            g.addColorStop(0, 'rgba(0,255,140,0.18)');
            g.addColorStop(1, 'rgba(0,255,140,0)');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(px+tile/2,py+tile/2,tile*0.9,0,Math.PI*2); ctx.fill();
          }
        }
      }

      // Jogador
      ctx.fillStyle = '#e33';
      ctx.beginPath();
      ctx.arc(player.x*tile + tile/2, player.y*tile + tile/2, tile*0.35, 0, Math.PI*2);
      ctx.fill();

      // Efeito de iluminação (lanterna)
      const lightX = player.x*tile + tile/2;
      const lightY = player.y*tile + tile/2;
      const r = lightingRadius * tile;
      const g = ctx.createRadialGradient(lightX, lightY, r*0.2, lightX, lightY, r);
      g.addColorStop(0,'rgba(255,255,255,0)');
      g.addColorStop(0.6,'rgba(0,0,0,0.25)');
      g.addColorStop(1,'rgba(0,0,0,0.82)');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

      // Vinheta nas bordas (sombrio)
      const vg = ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2.2, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)/1.1);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, 'rgba(0,0,0,0.7)');
      ctx.fillStyle = vg; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function getWallShade(x,y){
      // sutil variação para dar textura
      const n = (x*13 + y*7) % 10;
      const base = 0x27; // 39
      const shade = base + n; // 39..48
      return `rgb(${shade},${shade+1},${shade+4})`;
    }

    function canMove(nx, ny){
      const level = LEVELS[currentLevel];
      if(ny<0 || ny>=level.length || nx<0 || nx>=level[0].length) return false;
      return level[ny][nx] !== 1;
    }

    function move(dx, dy){
      const nx = player.x + dx;
      const ny = player.y + dy;
      const level = LEVELS[currentLevel];
      if(!canMove(nx,ny)) return;
      player.x = nx; player.y = ny;
      // saída
      if(level[ny][nx] === 2){
        if(currentLevel < LEVELS.length-1){
          currentLevel++;
          startLevel();
          showToast(`Fase ${currentLevel+1}`);
        }else{
          winOverlay.style.display = 'flex';
        }
      } else {
        draw();
      }
    }

    function startLevel(){
      const level = LEVELS[currentLevel];
      const start = findStart(level);
      player.x = start.x; player.y = start.y;
      levelInfo.textContent = `Fase ${currentLevel+1}/15`;
      lightingRadius = 2.0 + Math.min(3, Math.floor(currentLevel/5)) * 0.2; // levemente mais amplo em fases maiores
      resizeCanvas();
    }

    // --- Entradas ---
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(['arrowup','w','arrowdown','s','arrowleft','a','arrowright','d'].includes(k)){
        e.preventDefault();
      }
      if(k==='arrowup' || k==='w') move(0,-1);
      if(k==='arrowdown' || k==='s') move(0,1);
      if(k==='arrowleft' || k==='a') move(-1,0);
      if(k==='arrowright' || k==='d') move(1,0);
    }, {passive:false});

    const joystick = document.getElementById("joystick");
const stick = document.getElementById("stick");

let center = {x: 0, y: 0};
let active = false;

function getDir(dx, dy) {
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx > 0 ? "right" : "left";
  } else {
    return dy > 0 ? "down" : "up";
  }
}

joystick.addEventListener("touchstart", e => {
  active = true;
  const rect = joystick.getBoundingClientRect();
  center = {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
});

joystick.addEventListener("touchmove", e => {
  if (!active) return;
  const touch = e.touches[0];
  const dx = touch.clientX - center.x;
  const dy = touch.clientY - center.y;
  const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40); // limite
  const angle = Math.atan2(dy, dx);

  // move o stick visualmente
  stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;

  // envia direção
  const dir = getDir(dx, dy);
  movePlayer(dir); // <-- chama sua função que move o personagem
});

joystick.addEventListener("touchend", e => {
  active = false;
  stick.style.transform = "translate(0,0)";
});


    // --- Fluxo ---
    btnStart.addEventListener('click', ()=>{
      startOverlay.style.display = 'none';
      currentLevel = 0; startLevel();
    });
    btnRestart.addEventListener('click', ()=>{
      winOverlay.style.display = 'none';
      currentLevel = 0; startLevel();
    });

    // Desenha uma prévia atrás do overlay
    resizeCanvas();
  </script>
</body>
</html>
